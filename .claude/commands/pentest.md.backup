---
name: pentest
description: Execute automated penetration test using multi-agent orchestration
usage: /pentest <target> [options]
examples:
  - /pentest 10.10.10.10
  - /pentest 10.10.10.10 --mode aggressive
  - /pentest 10.10.10.10 --stealth --report detailed
allowed-tools: ["Bash(*)", "Read(*)", "Write(*)", "Edit(*)", "Grep(*)", "Glob(*)", "Task", "TodoWrite", "WebFetch", "WebSearch"]
model: "claude-opus-4-1-20250805"
thinking: true
---

# /pentest Command Implementation

## Command Overview

The `/pentest` command initiates an automated penetration testing workflow that leverages multiple specialized agents to systematically compromise target systems. Based on decision tree analysis from 23 Hack The Box machines, this command implements proven attack patterns with intelligent decision-making.

## Usage

```bash
/pentest <target> [summary] [options]
```

### Parameters

- `<target>` (required): IP address or hostname of the target system
- `[summary]` (optional): Key details, passwords, hints in quotes
- `[options]` (optional): Modify behavior with flags

### Summary Format
The summary parameter allows you to provide crucial context:
```bash
/pentest 10.10.10.10 "password: Summer2023!, users: john,admin, hint: check FTP for configs, note: vulnerable to log4j"

/pentest 192.168.1.100 "domain: corp.local, user: svc_backup, password: Password123, note: kerberoastable service accounts"

/pentest k8s.example.com "namespace: production, token: eyJhbGc..., hint: misconfigured RBAC"
```

### Options

| Option | Description | Default |
|--------|-------------|---------|
| `--mode <type>` | Execution mode: normal, aggressive, stealth | normal |
| `--report <level>` | Report detail: minimal, standard, detailed | standard |
| `--ports <range>` | Port range to scan | 1-65535 |
| `--timeout <seconds>` | Maximum time per phase | 600 |
| `--no-privesc` | Skip privilege escalation | false |
| `--no-loot` | Skip data extraction | false |
| `--resume <session>` | Resume from checkpoint | none |
| `--output <path>` | Report output directory | ./reports |

## Execution Flow

```javascript
async function executePentest(target, summary = null, options = {}) {
    // Step 1: Validate inputs
    if (!validateTarget(target)) {
        return { error: "Invalid target format" };
    }

    // Step 2: Parse summary if provided
    const context = parseSummary(summary);
    if (context.credentials.length > 0) {
        console.log(`ğŸ“‹ Loaded ${context.credentials.length} credentials from summary`);
    }
    if (context.hints.length > 0) {
        console.log(`ğŸ’¡ Processing ${context.hints.length} hints`);
    }

    // Step 3: Initialize Tool Manager
    const toolManager = new ToolManager();
    toolManager.detectAllTools();

    // Check for essential tools
    const essentialsMissing = toolManager.generateToolReport().missing_essentials;
    if (essentialsMissing.length > 0) {
        console.log("âš ï¸  Missing essential tools, attempting alternatives...");
        for (const tool of essentialsMissing) {
            console.log(`  ${tool.name}: ${tool.alternatives || 'No alternative found'}`);
        }
    }

    // Step 4: Initialize session with tool awareness and context
    const session = {
        id: generateSessionId(),
        target: target,
        startTime: Date.now(),
        options: options,
        status: 'initializing',
        toolManager: toolManager,
        toolExecutor: new ToolExecutor(toolManager),
        context: context,  // Summary data
        knownCredentials: context.credentials,
        hints: context.hints,
        vulnerabilities: context.vulnerabilities
    };

    // Step 3: Direct Execution - No agent orchestration needed
    // The command itself will execute all phases directly

    // Step 4: Execute Reconnaissance
    updateStatus("ğŸ” Phase 1: Reconnaissance");
    const reconResults = await executeReconnaissance(target, context);

    // Step 5: Analyze and Prioritize
    updateStatus("ğŸ¯ Analyzing attack surface...");
    const attackPlan = await analyzeResults(reconResults);

    // Step 6: Execute Exploitation
    updateStatus("ğŸ’¥ Phase 2: Exploitation");
    const exploitResults = await executeExploitation(target, attackPlan, context);

    // Step 7: Privilege Escalation (if enabled)
    if (!options.noPrivesc && exploitResults.access) {
        updateStatus("ğŸ“ˆ Phase 3: Privilege Escalation");
        const privescResults = await executePrivilegeEscalation(exploitResults.access);
    }

    // Step 8: Data Extraction (if enabled)
    if (!options.noLoot && (exploitResults.access || privescResults?.root)) {
        updateStatus("ğŸ’ Phase 4: Data Extraction");
        const lootResults = await executeDataExtraction(privescResults?.root || exploitResults.access);
    }

    // Step 9: Generate Report
    updateStatus("ğŸ“Š Generating report...");
    const report = await orchestrator.generateReport(session);

    return report;
}
```

## Command Implementation Structure

### 1. Input Validation and Summary Parsing

```javascript
function validateTarget(target) {
    // IP address validation
    const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
    if (ipRegex.test(target)) {
        const octets = target.split('.');
        return octets.every(octet => parseInt(octet) <= 255);
    }

    // Hostname validation
    const hostnameRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    return hostnameRegex.test(target);
}

function parseSummary(summary) {
    const context = {
        credentials: [],
        hints: [],
        vulnerabilities: [],
        notes: [],
        domain: null,
        tokens: [],
        services: {}
    };

    if (!summary) return context;

    // Parse key:value pairs and special patterns
    const patterns = {
        // Credentials patterns
        password: /password[s]?\s*:\s*([^,]+)/gi,
        username: /user[s]?\s*:\s*([^,]+)/gi,
        credential: /cred[s]?\s*:\s*([^:,]+):([^,]+)/gi,

        // Domain patterns
        domain: /domain\s*:\s*([^,]+)/gi,

        // Token patterns
        token: /token\s*:\s*([^,\s]+)/gi,
        jwt: /jwt\s*:\s*([^,\s]+)/gi,
        apikey: /api[_-]?key\s*:\s*([^,\s]+)/gi,

        // Hints and notes
        hint: /hint\s*:\s*([^,]+)/gi,
        note: /note\s*:\s*([^,]+)/gi,

        // Vulnerabilities
        vuln: /vuln(?:erable)?\s*(?:to)?\s*:\s*([^,]+)/gi,
        cve: /(CVE-\d{4}-\d+)/gi,

        // Services
        service: /service\s*:\s*([^,]+)/gi,
        port: /port\s*:\s*(\d+)/gi
    };

    // Extract passwords
    let match;
    while ((match = patterns.password.exec(summary)) !== null) {
        const passwords = match[1].trim().split(/[,\s]+/);
        passwords.forEach(pass => {
            if (pass) context.credentials.push({ type: 'password', value: pass });
        });
    }

    // Extract usernames
    while ((match = patterns.username.exec(summary)) !== null) {
        const users = match[1].trim().split(/[,\s]+/);
        users.forEach(user => {
            if (user) context.credentials.push({ type: 'username', value: user });
        });
    }

    // Extract user:pass credentials
    while ((match = patterns.credential.exec(summary)) !== null) {
        context.credentials.push({
            type: 'credential',
            username: match[1].trim(),
            password: match[2].trim()
        });
    }

    // Extract domain
    if ((match = patterns.domain.exec(summary)) !== null) {
        context.domain = match[1].trim();
    }

    // Extract tokens
    while ((match = patterns.token.exec(summary)) !== null) {
        context.tokens.push({ type: 'token', value: match[1].trim() });
    }
    while ((match = patterns.jwt.exec(summary)) !== null) {
        context.tokens.push({ type: 'jwt', value: match[1].trim() });
    }
    while ((match = patterns.apikey.exec(summary)) !== null) {
        context.tokens.push({ type: 'apikey', value: match[1].trim() });
    }

    // Extract hints
    while ((match = patterns.hint.exec(summary)) !== null) {
        context.hints.push(match[1].trim());
    }

    // Extract notes
    while ((match = patterns.note.exec(summary)) !== null) {
        context.notes.push(match[1].trim());
    }

    // Extract vulnerabilities
    while ((match = patterns.vuln.exec(summary)) !== null) {
        context.vulnerabilities.push(match[1].trim());
    }
    while ((match = patterns.cve.exec(summary)) !== null) {
        context.vulnerabilities.push(match[1]);
    }

    // Special vulnerability keywords
    const vulnKeywords = ['log4j', 'eternal blue', 'ms17-010', 'heartbleed', 'shellshock', 'apache struts'];
    vulnKeywords.forEach(vuln => {
        if (summary.toLowerCase().includes(vuln)) {
            context.vulnerabilities.push(vuln);
        }
    });

    // Build credential combinations
    const usernames = context.credentials.filter(c => c.type === 'username').map(c => c.value);
    const passwords = context.credentials.filter(c => c.type === 'password').map(c => c.value);

    // Add credential pairs for direct credentials
    const directCreds = context.credentials.filter(c => c.type === 'credential');

    // Combine usernames and passwords if both exist
    if (usernames.length > 0 && passwords.length > 0) {
        usernames.forEach(user => {
            passwords.forEach(pass => {
                directCreds.push({ username: user, password: pass });
            });
        });
    }

    context.credentialPairs = directCreds;

    return context;
}
```

### 2. Agent Coordination

```javascript
class PentestOrchestrator {
    constructor(session) {
        this.session = session;
        this.agents = {};
        this.results = {};
    }

    async launchAgent(agentName, config) {
        this.agents[agentName] = await Task({
            subagent_type: agentName,
            description: `Launch ${agentName}`,
            prompt: JSON.stringify(config)
        });
        return this.agents[agentName];
    }

    async executePhase(phaseName, config) {
        const startTime = Date.now();

        try {
            const agent = await this.launchAgent(config.agent, config);
            const result = await agent.execute();

            this.results[phaseName] = {
                success: result.success,
                data: result.data,
                duration: Date.now() - startTime
            };

            return result;
        } catch (error) {
            return this.handlePhaseError(phaseName, error);
        }
    }

    async handlePhaseError(phaseName, error) {
        console.error(`Phase ${phaseName} failed:`, error);

        // Attempt recovery
        if (this.canRecover(phaseName)) {
            return this.recoverPhase(phaseName);
        }

        return { success: false, error: error.message };
    }
}
```

### 3. Progress Tracking

```javascript
class ProgressTracker {
    constructor() {
        this.phases = [
            { name: 'reconnaissance', status: 'pending', progress: 0 },
            { name: 'exploitation', status: 'pending', progress: 0 },
            { name: 'privilege_escalation', status: 'pending', progress: 0 },
            { name: 'data_extraction', status: 'pending', progress: 0 }
        ];
    }

    updatePhase(phaseName, status, progress = 0) {
        const phase = this.phases.find(p => p.name === phaseName);
        if (phase) {
            phase.status = status;
            phase.progress = progress;
            this.displayProgress();
        }
    }

    displayProgress() {
        console.clear();
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('            AUTOMATED PENETRATION TEST                 ');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

        this.phases.forEach(phase => {
            const icon = this.getStatusIcon(phase.status);
            const bar = this.getProgressBar(phase.progress);
            console.log(`${icon} ${phase.name.padEnd(20)} ${bar} ${phase.progress}%`);
        });

        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    }

    getStatusIcon(status) {
        const icons = {
            pending: 'â³',
            running: 'ğŸ”„',
            completed: 'âœ…',
            failed: 'âŒ',
            skipped: 'â©'
        };
        return icons[status] || 'â“';
    }

    getProgressBar(progress) {
        const filled = Math.floor(progress / 5);
        const empty = 20 - filled;
        return 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
    }
}
```

### 4. Attack Decision Logic

```javascript
function determineAttackStrategy(services) {
    const strategy = {
        immediate: [],  // Priority 1: Instant win conditions
        high: [],       // Priority 2: High success rate
        medium: [],     // Priority 3: Standard attacks
        low: []         // Priority 4: Last resort
    };

    services.forEach(service => {
        // FTP with anonymous access = immediate win
        if (service.port === 21 && service.anonymous) {
            strategy.immediate.push({
                service: 'ftp',
                method: 'anonymous_login',
                confidence: 0.99
            });
        }
        // SMB null sessions
        else if (service.port === 445) {
            strategy.high.push({
                service: 'smb',
                method: 'null_session',
                confidence: 0.75
            });
        }
        // Web applications
        else if ([80, 443].includes(service.port)) {
            strategy.high.push({
                service: 'web',
                method: 'vulnerability_scan',
                confidence: 0.85
            });
        }
        // SSH with discovered users
        else if (service.port === 22 && service.users) {
            strategy.medium.push({
                service: 'ssh',
                method: 'credential_spray',
                confidence: 0.60
            });
        }
        // Database services
        else if ([3306, 5432, 1433].includes(service.port)) {
            strategy.medium.push({
                service: 'database',
                method: 'default_credentials',
                confidence: 0.70
            });
        }
    });

    return strategy;
}
```

### 5. Real-time Output

```javascript
class RealTimeLogger {
    constructor() {
        this.startTime = Date.now();
        this.findings = [];
    }

    log(level, message, data = null) {
        const timestamp = this.getElapsedTime();
        const formatted = this.formatMessage(level, message, timestamp);

        console.log(formatted);

        if (data) {
            this.findings.push({ timestamp, level, message, data });
        }
    }

    formatMessage(level, message, timestamp) {
        const colors = {
            info: '\x1b[36m',    // Cyan
            success: '\x1b[32m',  // Green
            warning: '\x1b[33m',  // Yellow
            error: '\x1b[31m',    // Red
            critical: '\x1b[35m'  // Magenta
        };

        const reset = '\x1b[0m';
        const color = colors[level] || reset;

        return `[${timestamp}] ${color}[${level.toUpperCase()}]${reset} ${message}`;
    }

    getElapsedTime() {
        const elapsed = Date.now() - this.startTime;
        const minutes = Math.floor(elapsed / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
}
```

### 6. Report Generation

```javascript
async function generateReport(session, results) {
    const report = {
        metadata: {
            session_id: session.id,
            target: session.target,
            start_time: session.startTime,
            end_time: Date.now(),
            duration: Date.now() - session.startTime,
            command: `/pentest ${session.target} ${Object.entries(session.options).map(([k,v]) => `--${k} ${v}`).join(' ')}`
        },
        summary: {
            services_discovered: results.reconnaissance?.services.length || 0,
            vulnerabilities_found: countVulnerabilities(results),
            access_gained: results.exploitation?.success || false,
            privilege_escalated: results.privesc?.success || false,
            credentials_discovered: countCredentials(results),
            files_extracted: results.loot?.files.length || 0
        },
        phases: {
            reconnaissance: formatPhaseResults(results.reconnaissance),
            exploitation: formatPhaseResults(results.exploitation),
            privilege_escalation: formatPhaseResults(results.privesc),
            data_extraction: formatPhaseResults(results.loot)
        },
        attack_chain: buildAttackChain(results),
        recommendations: generateRecommendations(results),
        evidence: collectEvidence(results)
    };

    // Save report
    const reportPath = await saveReport(report, session.options.output);

    // Display summary
    displayReportSummary(report);

    return report;
}
```

## Example Outputs

### Successful Execution
```
$ /pentest 10.10.10.27

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            AUTOMATED PENETRATION TEST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âœ… reconnaissance            â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%
âœ… exploitation             â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%
âœ… privilege_escalation     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%
âœ… data_extraction          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[00:30] [SUCCESS] Penetration test completed!

ğŸ“Š SUMMARY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Target:              10.10.10.27
Duration:            00:08:42
Services Found:      5 (FTP, SSH, HTTP, SMB, MySQL)
Initial Access:      FTP Anonymous â†’ SSH (christine)
Privilege Escalation: Sudo vim misconfiguration
Root Access:         âœ… Achieved

ğŸ¯ ATTACK CHAIN
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. FTP Anonymous Login â†’ Downloaded credentials
2. SSH Password Spray â†’ Access as 'christine'
3. Sudo -l Discovery â†’ vim with NOPASSWD
4. Sudo vim Exploit â†’ Root shell obtained
5. Data Extraction â†’ 15 files, 3 databases

ğŸ“ Report saved to: ./reports/pentest_10.10.10.27_20240101.json
```

### Partial Success
```
$ /pentest 10.10.10.50 --mode stealth

[05:23] [WARNING] Exploitation phase partially successful
[07:45] [INFO] Limited access achieved - user 'www-data'
[10:12] [WARNING] Privilege escalation failed - no vectors found
[12:30] [SUCCESS] Data extraction completed with limited scope

ğŸ“Š RESULTS: Partial compromise achieved
- Web shell access obtained
- 3 configuration files extracted
- Database credentials discovered
- Root access: âŒ Not achieved
```

## Error Handling

### Common Errors

| Error | Cause | Resolution |
|-------|-------|------------|
| Target unreachable | Network issue | Check connectivity |
| No services found | Firewall/IDS | Try stealth mode |
| All exploits failed | Hardened system | Manual review needed |
| Agent timeout | Complex target | Increase timeout |

### Error Recovery Example
```javascript
async function recoverFromError(error, context) {
    switch(error.type) {
        case 'NETWORK_ERROR':
            await delay(5000);
            return retry(context.lastAction);

        case 'EXPLOIT_FAILED':
            return tryAlternativeExploit(context);

        case 'AGENT_CRASH':
            return restartAgent(context.agent);

        default:
            return requestManualIntervention(error);
    }
}
```

## Performance Optimization

### Caching Mechanisms
```javascript
const cache = {
    serviceFingerprints: new Map(),
    exploitResults: new Map(),
    credentialTests: new Map()
};

function getCachedOrExecute(key, executor) {
    if (cache.has(key)) {
        return cache.get(key);
    }
    const result = executor();
    cache.set(key, result);
    return result;
}
```

## Integration Examples

### With Other Commands
```bash
# Quick scan first, then targeted pentest
/quick-scan 10.10.10.10
/pentest 10.10.10.10 --focus web

# Chain with specific service exploitation
/pentest 10.10.10.10 --no-privesc
/privesc-check

# Resume after network interruption
/pentest --resume session_12345
```

Remember: This command represents the culmination of empirical penetration testing knowledge. Use responsibly and only on authorized targets.
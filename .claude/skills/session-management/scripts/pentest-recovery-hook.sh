#!/bin/bash
#
# Pentest Recovery Hook - Ralph-style iterative recovery
# Implements automatic retry logic for failed pentest attempts
#

set -euo pipefail

RECOVERY_STATE_FILE="$HOME/.claude/pentest-recovery.yaml"
MAX_RECOVERY_ATTEMPTS=5

# Check if recovery is active
check_recovery_active() {
    if [ ! -f "$RECOVERY_STATE_FILE" ]; then
        return 1
    fi

    local active=$(grep "^active:" "$RECOVERY_STATE_FILE" | cut -d' ' -f2)
    if [ "$active" = "true" ]; then
        return 0
    fi

    return 1
}

# Initialize recovery state
init_recovery() {
    local target="$1"
    local failure_type="$2"

    cat > "$RECOVERY_STATE_FILE" << EOF
---
active: true
target: $target
failure_type: $failure_type
iteration: 1
max_iterations: $MAX_RECOVERY_ATTEMPTS
started_at: $(date +%s)
strategies_tried: []
completion_promise: FOOTHOLD_ACHIEVED
---
EOF

    echo "Recovery mode activated for $target (failure: $failure_type)"
}

# Update recovery iteration
update_iteration() {
    local current=$(grep "^iteration:" "$RECOVERY_STATE_FILE" | cut -d' ' -f2)
    local max=$(grep "^max_iterations:" "$RECOVERY_STATE_FILE" | cut -d' ' -f2)

    local next=$((current + 1))

    if [ "$next" -gt "$max" ]; then
        echo "Maximum recovery attempts ($max) reached"
        deactivate_recovery
        return 1
    fi

    sed -i "s/^iteration: .*/iteration: $next/" "$RECOVERY_STATE_FILE"
    echo "Recovery iteration $next of $max"
    return 0
}

# Add tried strategy
add_tried_strategy() {
    local strategy="$1"

    # Append to strategies_tried list in YAML
    sed -i "/^strategies_tried:/a\ \ - $strategy" "$RECOVERY_STATE_FILE"
}

# Get next recovery strategy based on failure type
get_next_strategy() {
    local failure_type="$1"
    local iteration="$2"

    case "$failure_type" in
        "connection_refused")
            case "$iteration" in
                1) echo "stealth_scan" ;;
                2) echo "alternative_ports" ;;
                3) echo "proxy_attempt" ;;
                4) echo "timing_adjustment" ;;
                *) echo "manual_investigation" ;;
            esac
            ;;
        "authentication_failed")
            case "$iteration" in
                1) echo "credential_variations" ;;
                2) echo "username_as_password" ;;
                3) echo "common_passwords" ;;
                4) echo "credential_stuffing" ;;
                *) echo "brute_force_limited" ;;
            esac
            ;;
        "exploit_failed")
            case "$iteration" in
                1) echo "version_verification" ;;
                2) echo "alternative_exploit" ;;
                3) echo "manual_exploitation" ;;
                4) echo "payload_encoding" ;;
                *) echo "exploit_chaining" ;;
            esac
            ;;
        "no_vector_found")
            case "$iteration" in
                1) echo "full_port_scan" ;;
                2) echo "udp_scan" ;;
                3) echo "version_scanning" ;;
                4) echo "web_discovery" ;;
                *) echo "aggressive_enumeration" ;;
            esac
            ;;
        *)
            echo "generic_recovery"
            ;;
    esac
}

# Execute recovery strategy
execute_strategy() {
    local strategy="$1"
    local target="$2"

    echo "Executing recovery strategy: $strategy"

    case "$strategy" in
        "stealth_scan")
            echo "Performing stealth scan with reduced speed..."
            echo "nmap -sS -T2 -p- $target"
            ;;
        "alternative_ports")
            echo "Checking alternative service ports..."
            echo "nmap -p 2222,8080,8443,9090 $target"
            ;;
        "credential_variations")
            echo "Trying credential variations..."
            echo "Testing: Admin/admin, Administrator/administrator, root/toor"
            ;;
        "full_port_scan")
            echo "Running full TCP port scan..."
            echo "nmap -p- -T4 $target"
            ;;
        "version_verification")
            echo "Verifying exact service versions..."
            echo "nmap -sV -sC -p- $target"
            ;;
        *)
            echo "Strategy $strategy not yet implemented"
            ;;
    esac

    add_tried_strategy "$strategy"
}

# Check for completion
check_completion() {
    local promise=$(grep "^completion_promise:" "$RECOVERY_STATE_FILE" | cut -d' ' -f2)

    # Check last session output for completion promise
    if [ -f "$HOME/.claude/sessions/latest/transcript.json" ]; then
        if grep -q "$promise" "$HOME/.claude/sessions/latest/transcript.json"; then
            echo "Recovery successful! Completion promise found: $promise"
            deactivate_recovery
            return 0
        fi
    fi

    return 1
}

# Deactivate recovery
deactivate_recovery() {
    if [ -f "$RECOVERY_STATE_FILE" ]; then
        sed -i "s/^active: .*/active: false/" "$RECOVERY_STATE_FILE"
        echo "Recovery mode deactivated"
    fi
}

# Main recovery loop
main() {
    local action="${1:-check}"

    case "$action" in
        init)
            init_recovery "$2" "$3"
            ;;
        check)
            if check_recovery_active; then
                echo "Recovery is active"

                # Check for completion
                if check_completion; then
                    exit 0
                fi

                # Get current state
                local target=$(grep "^target:" "$RECOVERY_STATE_FILE" | cut -d' ' -f2)
                local failure_type=$(grep "^failure_type:" "$RECOVERY_STATE_FILE" | cut -d' ' -f2)
                local iteration=$(grep "^iteration:" "$RECOVERY_STATE_FILE" | cut -d' ' -f2)

                # Get and execute next strategy
                local strategy=$(get_next_strategy "$failure_type" "$iteration")
                execute_strategy "$strategy" "$target"

                # Update iteration
                update_iteration
            else
                echo "No active recovery"
            fi
            ;;
        stop)
            deactivate_recovery
            ;;
        *)
            echo "Usage: $0 {init|check|stop}"
            exit 1
            ;;
    esac
}

# Run if executed directly
if [ "${BASH_SOURCE[0]}" == "${0}" ]; then
    main "$@"
fi